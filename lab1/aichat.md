

The thing doesn't format if for me when i try to ask it to. It gives me a blob instead.



# **Transcript**
**User Prompt 1:** is this valid yaml # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by:Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 1:** That YAML is not valid due to a few syntax errors, particularly around the **`reviewer_for`** key and the use of the dollar sign (`$`) in the text. While the overall structure is close, it fails to meet the strict rules of YAML syntax. --- ### **Specific YAML Errors** * **Invalid `reviewer_for` Key:** The `reviewer_for: Richard Kang` line has a trailing space after the colon, which can cause a parser error. While some parsers might be lenient, the correct syntax is `reviewer_for: Richard Kang` without the extra space. * **Use of the `$` Symbol:** In the **`example_program`** and **`language_syntax`** sections, the dollar sign (`$`) is used without being properly escaped or quoted. The dollar sign has special meaning in YAML as an anchor for a reusable node. When a character has a special meaning and needs to be treated as a literal string, it must be enclosed in quotes (single or double). The use of the dollar sign in the unquoted text is a syntax violation. ### **Corrected YAML Example** To make the YAML valid, you must enclose the text containing the dollar signs in quotes. A **block scalar** is the best way to handle multiline strings with special characters, such as the ones you have.  The use of the pipe `|` indicates a literal block scalar, which preserves newlines, but it doesn't escape special characters like `$`. Therefore, you need to use a quoted style or ensure the text itself is not violating the parser's rules. Here's an example of how to fix the `example_program` section using a single-quoted string, which treats all characters literally: ```yaml example_program: ' $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won''t screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ' ``` Alternatively, you could use a double-quoted string and escape the dollar signs, but this would be more cumbersome. The simplest solution to ensure validity is to quote the strings where you use special characters that could be misinterpreted by a YAML parser. The other text blocks like `language_syntax` and `language_semantics` also require similar corrections if they are intended to be parsed as literal strings containing special characters. **User Prompt 2:** will that do anything massive or is that it? **Response 2:** While it may not do anything "massive" in the sense of crashing your computer, the invalid YAML will cause a **parsing error** when a program tries to read it. The YAML parser will stop processing the file at the point of the error, and the program will not be able to access any of the data. In a programming context, this means that the application or script that relies on this configuration file would fail to load or run correctly. For example, a program that's supposed to read the `language_name` or `example_program` would stop working and likely throw an error message. It's a critical syntax failure that prevents the file from being used as intended. **User Prompt 3:** so is my format valid yamal? **Response 3:** No, your YAML format is not valid. The presence of the dollar sign (`$`) in unquoted strings is the primary reason it will fail to parse. YAML has specific rules for special characters, and the dollar sign is one of them. It is used in YAML for **anchors and aliases**, which are features that let you reuse a block of code. When a YAML parser sees a `$` that is not enclosed in quotes, it will try to interpret it as part of an anchor or alias, and when it doesn't match the expected syntax, it will throw an error. To make your YAML valid, you must either: * **Quote the strings** that contain the `$` symbol, for example, using single quotes (`'`) or double quotes (`"`). * **Use block scalars** like the `|` (literal) or `>` (folded) characters, which are designed to handle multi-line strings with special characters. For example, to fix the `example_program` block, you would change it to: ```yaml example_program: | $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ``` While the `|` and `>` operators are a good way to handle multi-line text, they don't solve the issue if the `$ $` is meant to be a comment *within* the YAML. YAML's official comment character is `#`, so the text `$ Hello...` is not a valid YAML comment. The parser will also likely throw an error for the trailing space after the colon in `reviewer_for: Richard Kang` if it's a strict parser, though some may be more lenient. The correct syntax is `reviewer_for: Richard Kang`. In short, your YAML is **not valid** and will fail to parse because of the unquoted dollar signs, which have a special, reserved meaning in the YAML syntax. **User Prompt 4:** i fixed it is it valid now # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by: Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 4:** No, the YAML is still not valid. The primary issue remains the unquoted dollar signs (`$`) in the `example_program` block. YAML parsers will fail when they encounter these characters because `$` has a special meaning for anchors and aliases within the YAML syntax. --- ### **Specific Issues and Why They Matter** * **Unquoted `$ $`:** You've used a block scalar (`|`) for `example_program`, which is the correct way to handle multiline text. However, even within a block scalar, a YAML parser will still interpret special characters like `$`. The characters `$ $` are not a standard YAML comment syntax (which is `#`), so the parser will try to interpret them as an anchor, which will fail and stop the parsing process. To be valid YAML, you must either remove the `$` signs, or enclose the text containing them in quotes. * **YAML's comment syntax:** A YAML parser only recognizes the `#` character as the beginning of a comment. It ignores all other characters that don't conform to the YAML specification. The `$ $` syntax is a description of a comment style for your "Just Strings language," not a valid comment in the YAML file itself. ### **How to Fix It** To make the YAML valid, you must remove the dollar signs from the `example_program` block, as they are not valid YAML syntax. The `#` at the beginning of the `example_input_1` and `example_output_1` lines is a valid YAML comment character, so those lines will be ignored by the YAML parser. A valid `example_program` block would look like this: ```yaml example_program: | -d:"Hello World Part2" command -i -r -c:"World is cool" -d ```  **User Prompt 5:** the reviewed by and reviewed passed section is not right for some reason # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by: Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 5:** Based on the YAML provided, the `reviewed_by` key has a leading space before the value, which can cause a syntax error in some strict YAML parsers. The correct syntax for key-value pairs requires the value to immediately follow the colon, with only a single space for separation. While some parsers might be lenient and process it correctly, it's not considered valid YAML. Additionally, as noted previously, the entire file has invalid YAML syntax due to the unquoted dollar signs (`$`) in the `example_program` section. *** ### **YAML Syntax Errors** Your YAML file contains several syntax errors that make it invalid. The most significant issue is the presence of unquoted dollar signs (`$`) outside of a valid YAML context. In YAML, the dollar sign has a special meaning and cannot be used as a literal character without being properly escaped or placed within a quoted string. The `example_program` block uses `$ $` to represent a comment in the "Just Strings language" you're defining, but a YAML parser will see this as an invalid syntax. ### **Correcting the YAML** To fix the `reviewed_by` key, simply remove the leading space: **Incorrect:** `reviewed_by: Ellijah Baquiran` **Correct:** `reviewed_by: Ellijah Baquiran` The `review_passed` key is correctly formatted. However, to make the entire YAML file valid, you must also fix the `example_program` block. Since the `$ $` is part of your custom language's syntax and not meant to be a YAML comment, you must enclose the entire block in quotes to treat it as a literal string. The most effective way to handle this multi-line string is to use a **literal block scalar** (`|`). However, since a literal block scalar still attempts to parse special characters, the dollar signs will still cause an error. The best solution is to either remove the dollar signs from the YAML or enclose the entire text containing them in a single-quoted string. Here's how to fix the `example_program` section using a single-quoted string, which treats all characters literally: ```yaml example_program: ' $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won''t screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ' ```  Note the use of two single quotes (`''`) for the single quote within "won't," which is required for a single-quoted string in YAML. Alternatively, you could remove the dollar signs from the YAML file entirely, since they are part of the syntax you are describing and not part of the YAML itself. The YAML file should be a valid data structure, not an example of your language's syntax. ```yaml example_program: | -d:"Hello World Part2" command -i -r -c:"World is cool" -d ``` **User Prompt 6:** what should i fix for review passed **Response 6:** You shouldn't fix anything in the `review_passed` section. The `review_passed: Y` key-value pair is valid YAML. The issue in your YAML is with the **spacing** in `reviewed_by: Ellijah Baquiran`, not the `review_passed` section. While some YAML parsers might be lenient, the correct syntax for key-value pairs requires only one space after the colon. The extra space before "Ellijah" could cause a syntax error in a strict YAML parser. ### **Incorrect:** ```yaml reviewed_by: Ellijah Baquiran ``` ### **Correct:** ```yaml reviewed_by: Ellijah Baquiran ``` This is a minor point, but it's important for creating valid YAML. However, the biggest problem with your YAML is the use of the dollar sign (`$`) in the `example_program` block. Since `$` has a special meaning in YAML, it will cause a parsing error and prevent the file from being read correctly. The `reviewed_by` spacing is a very small issue compared to that.  **User Prompt 7:** can you make it one line so i can copy it **Response 7:** Here is the complete conversation transcript in a single, continuous line. # **Transcript** **User Prompt 1:** is this valid yaml # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by:Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 1:** That YAML is not valid due to a few syntax errors, particularly around the **`reviewer_for`** key and the use of the dollar sign (`$`) in the text. While the overall structure is close, it fails to meet the strict rules of YAML syntax. --- ### **Specific YAML Errors** * **Invalid `reviewer_for` Key:** The `reviewer_for: Richard Kang` line has a trailing space after the colon, which can cause a parser error. While some parsers might be lenient, the correct syntax is `reviewer_for: Richard Kang` without the extra space. * **Use of the `$` Symbol:** In the **`example_program`** and **`language_syntax`** sections, the dollar sign (`$`) is used without being properly escaped or quoted. The dollar sign has special meaning in YAML as an anchor for a reusable node. When a character has a special meaning and needs to be treated as a literal string, it must be enclosed in quotes (single or double). The use of the dollar sign in the unquoted text is a syntax violation. ### **Corrected YAML Example** To make the YAML valid, you must enclose the text containing the dollar signs in quotes. A **block scalar** is the best way to handle multiline strings with special characters, such as the ones you have.  The use of the pipe `|` indicates a literal block scalar, which preserves newlines, but it doesn't escape special characters like `$`. Therefore, you need to use a quoted style or ensure the text itself is not violating the parser's rules. Here's an example of how to fix the `example_program` section using a single-quoted string, which treats all characters literally: ```yaml example_program: ' $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won''t screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ' ``` Alternatively, you could use a double-quoted string and escape the dollar signs, but this would be more cumbersome. The simplest solution to ensure validity is to quote the strings where you use special characters that could be misinterpreted by a YAML parser. The other text blocks like `language_syntax` and `language_semantics` also require similar corrections if they are intended to be parsed as literal strings containing special characters. **User Prompt 2:** will that do anything massive or is that it? **Response 2:** While it may not do anything "massive" in the sense of crashing your computer, the invalid YAML will cause a **parsing error** when a program tries to read it. The YAML parser will stop processing the file at the point of the error, and the program will not be able to access any of the data. In a programming context, this means that the application or script that relies on this configuration file would fail to load or run correctly. For example, a program that's supposed to read the `language_name` or `example_program` would stop working and likely throw an error message. It's a critical syntax failure that prevents the file from being used as intended. **User Prompt 3:** so is my format valid yamal? **Response 3:** No, your YAML format is not valid. The presence of the dollar sign (`$`) in unquoted strings is the primary reason it will fail to parse. YAML has specific rules for special characters, and the dollar sign is one of them. It is used in YAML for **anchors and aliases**, which are features that let you reuse a block of code. When a YAML parser sees a `$` that is not enclosed in quotes, it will try to interpret it as part of an anchor or alias, and when it doesn't match the expected syntax, it will throw an error. To make your YAML valid, you must either: * **Quote the strings** that contain the `$` symbol, for example, using single quotes (`'`) or double quotes (`"`). * **Use block scalars** like the `|` (literal) or `>` (folded) characters, which are designed to handle multi-line strings with special characters. For example, to fix the `example_program` block, you would change it to: ```yaml example_program: | $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ``` While the `|` and `>` operators are a good way to handle multi-line text, they don't solve the issue if the `$ $` is meant to be a comment *within* the YAML. YAML's official comment character is `#`, so the text `$ Hello...` is not a valid YAML comment. The parser will also likely throw an error for the trailing space after the colon in `reviewer_for: Richard Kang` if it's a strict parser, though some may be more lenient. The correct syntax is `reviewer_for: Richard Kang`. In short, your YAML is **not valid** and will fail to parse because of the unquoted dollar signs, which have a special, reserved meaning in the YAML syntax. **User Prompt 4:** i fixed it is it valid now # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by: Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 4:** No, the YAML is still not valid. The primary issue remains the unquoted dollar signs (`$`) in the `example_program` block. YAML parsers will fail when they encounter these characters because `$` has a special meaning for anchors and aliases within the YAML syntax. --- ### **Specific Issues and Why They Matter** * **Unquoted `$ $`:** You've used a block scalar (`|`) for `example_program`, which is the correct way to handle multiline text. However, even within a block scalar, a YAML parser will still interpret special characters like `$`. The characters `$ $` are not a standard YAML comment syntax (which is `#`), so the parser will try to interpret them as an anchor, which will fail and stop the parsing process. To be valid YAML, you must either remove the `$` signs, or enclose the text containing them in quotes. * **YAML's comment syntax:** A YAML parser only recognizes the `#` character as the beginning of a comment. It ignores all other characters that don't conform to the YAML specification. The `$ $` syntax is a description of a comment style for your "Just Strings language," not a valid comment in the YAML file itself. ### **How to Fix It** To make the YAML valid, you must remove the dollar signs from the `example_program` block, as they are not valid YAML syntax. The `#` at the beginning of the `example_input_1` and `example_output_1` lines is a valid YAML comment character, so those lines will be ignored by the YAML parser. A valid `example_program` block would look like this: ```yaml example_program: | -d:"Hello World Part2" command -i -r -c:"World is cool" -d ```  **User Prompt 5:** the reviewed by and reviewed passed section is not right for some reason # SI413 Lab 1.1: Spec for Just Strings language your_name: Richard Kang your_alpha: m263222 used_ai: Y # Task 1 language_name: Simple example_program: | $ Hello I am performing a nested commenteds $This is a second comment within the comment and won't screw up the code -d:"Hello World Part2" $$ command -i -r -c:"World is cool" -d example_input_1: | # Hello example_output_1: | # olleH World is cool example_input_2: | # Minecraft example_output_2: | # tfarceniM World is cool # Task 3 language_syntax: | A string literal is a double-quote character ", followed by a sequence of ordinary characters and escape sequences, followed by another double quote character. (Added Revision 1) Escape sequences start with a backslash \ (Added Revision 1) To include a $ inside of a string literal add a blackslash before the$ inside the string literal Any space, tab, or newlines will be treated as whitespace, unless if it is within "" Comments are created with two $. Anything in between the dollar signs will be considered a comment and will be ignored The code will consider all 95 basic ASCII printable characters besides, $, ", and \ The program will be performed with at least one action (-i, -d,-r,-c) language_semantics: | Commands: -i will read a single line of text from the console as a string in your program -d will display any string expression to the screen. d:"" can be used to specfiy a string to output. -d will add a newline when displaying it to the terminal -r will reverse any string expression producing a new string with the same characters in the reversed order. -r:"" can be used to specify string being reversed -c will concatenate two strings together. The 2nd string that will be concatenated will be specified with a -c"" with the 2nd string being within the double quotes comments will be created with two $. Anything in between the two dollar signs will be considered as a comment. Comments have no effect to the program The program will interpret the program from left to right. The order of operations: HIGHEST -r (reverse) -c (concatenation) -d (display) $ $ Comments LOWEST (Added Revision 1) Valid escapes are: \" \\ \$ \n These are used so that these characters can be written within a string literal (Added Revision 1) Comments: $ can be written inside of a string literal instead of being used as a comment by adding a backslash before it, otherwise the $ $ will be treated as a comment instead of a string. # Task 4 reviewer_for: Richard Kang reviewed_by: Ellijah Baquiran review_passed: Y reviewer_comments: | Order of operations for specifying which takes precedence over which **Response 5:** Based on the YAML provided, the `reviewed_by` key has a leading space before the value, which can cause a syntax error in some strict YAML parsers. The correct syntax for key-value pairs requires the value to immediately follow the colon, with only a single space for separation. While some parsers might be lenient and process it correctly, it's not considered valid YAML. Additionally, as noted previously, the entire file has invalid YAML syntax due to the unquoted dollar signs (`$`) in the `example_program` section. *** ### **YAML Syntax Errors** Your YAML file contains several syntax errors that make it invalid. The most significant issue is the presence of unquoted dollar signs (`$`) outside of a valid YAML context. In YAML, the dollar sign has a special meaning and cannot be used as a literal character without being properly escaped or placed within a quoted string. The `example_program` block uses `$ $` to represent a comment in the "Just Strings language" you're defining, but a YAML parser will see this as an invalid syntax. ### **Correcting the YAML** To fix the `reviewed_by` key, simply remove the leading space: **Incorrect:** `reviewed_by: Ellijah Baquiran` **Correct:** `reviewed_by: Ellijah Baquiran` The `review_passed` key is correctly formatted. However, to make the entire YAML file valid, you must also fix the `example_program` block. Since the `$ $` is part of your custom language's syntax and not meant to be a YAML comment, you must enclose the entire block in quotes to treat it as a literal string. The most effective way to handle this multi-line string is to use a **literal block scalar** (`|`). However, since a literal block scalar still attempts to parse special characters, the dollar signs will still cause an error. The best solution is to either remove the dollar signs from the YAML or enclose the entire text containing them in a single-quoted string. Here's how to fix the `example_program` section using a single-quoted string, which treats all characters literally: ```yaml example_program: ' $ Hello I am performing a nested commenteds $ This is a second comment within the comment and won''t screw up the code -d:"Hello World Part2" $ $ command -i -r -c:"World is cool" -d ' ```  Note the use of two single quotes (`''`) for the single quote within "won't," which is required for a single-quoted string in YAML. Alternatively, you could remove the dollar signs from the YAML file entirely, since they are part of the syntax you are describing and not part of the YAML itself. The YAML file should be a valid data structure, not an example of your language's syntax. ```yaml example_program: | -d:"Hello World Part2" command -i -r -c:"World is cool" -d ``` **User Prompt 6:** what should i fix for review passed **Response 6:** You shouldn't fix anything in the `review_passed` section. The `review_passed: Y` key-value pair is valid YAML. The issue in your YAML is with the **spacing** in `reviewed_by: Ellijah Baquiran`, not the `review_passed` section. While some YAML parsers might be lenient, the correct syntax for key-value pairs requires only one space after the colon. The extra space before "Ellijah" could cause a syntax error in a strict YAML parser. ### **Incorrect:** ```yaml reviewed_by: Ellijah Baquiran ``` ### **Correct:** ```yaml reviewed_by: Ellijah Baquiran ``` This is a minor point, but it's important for creating valid YAML. However, the biggest problem with your YAML is the use of the dollar sign (`$`) in the `example_program` block. Since `$` has a special meaning in YAML, it will cause a parsing error and prevent the file from being read correctly. The `reviewed_by` spacing is a very small issue compared to that. 

