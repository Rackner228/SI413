#!/usr/bin/env bash

set -euo pipefail
shopt -s nullglob

infofile_name='.clubinfo'

function usage {
  cat <<EOF
club: Command Line sUBmit script v1.5

Used to submit and/or see test case results for the USNA CS Department submit system.

Usage: ${0##*/} [FILES ...]

With FILES, tries to submit those files for some assignment and then show
the auto-testing results.

With no FILES given, just checks the test results of a previous submission.

The hidden file $infofile_name will created in the directory the first time you run
this, and will be used in later runs to determine the course and project.

OPTIONS:
  -cCOURSE or --course=COURSE
    Specify which course, e.g., "-c ic210"
  -pPROJECT or --project=PROJECT
    Specify which project, e.g., "-p lab01"
  -s[SID] or --sid[=SID]
    Check a prior submission according to the given SID.
    If you don't know the SID, just use "-s" and you can choose from a list.
  -uUSER or --user=USER
    (This option is only useful for instructors.)
    Specify the username to use, e.g., "-u m123456". Default is $USER.
    If the --names option is also given, the NAME here can be a display name.
  -nNAMESFILE or --names=NAMESFILE
    The file should contain lines "username displayname", like
      m123456 MIDN Soandso
    and then the system will show the displayname instead of the username when relevant.
  -f or --full
    Upload files with the full pathname given on the command line,
    like a/b/somefile.txt instead of just somefile.txt
  -r
    Before doing anything else, try to update ("refresh") club itself from gitlab
  -h or --help
    Display this help message and exit

club was written by Dr. Roche in September 2021. Use the gitlab page to
submit bug reports, or make your own improvements and submit a merge request:
  https://gitlab.usna.edu/roche/club
EOF
  [[ $# -eq 1 ]] && exit $1
}

function emsg {
  [[ $# -ge 1 ]] && echo "ERROR: $*" >&2
  echo "Run '${0##*/} -h' to get help" >&2
  exit 1
}

############################################################
### Check required tools exist
############################################################

need_tools=0
for cmd in curl jq mktemp; do
  if ! command -v "$cmd" >/dev/null; then
    echo "Required program '$cmd' not found"
    need_tools=1
  fi
done
if (( need_tools )); then
  cat <<EOF

Some required programs were not found installed on this system.
If you have sudo access on this (virtual) machine, run:
  sudo apt update
  sudo apt install -y curl jq coreutils
and enter your local (VM) password when prompted.
Then re-run this program after the installs are complete.
EOF
  exit 1
fi
unset need_tools

############################################################
### Default variable settings
############################################################

apifile="$HOME/.clubapikey"
infofile="$(pwd)/$infofile_name"
course=''
project=''
getprior=0
sid=''
user=$USER
setuser=0
namesfile=''
saveinfo=1
paths=0
refresh=0
CURL=${CURL:-curl}
poll_interval=${POLL:-15}
RED='\033[1;31m'
GREEN='\033[1;32m'
BLUE='\033[1;34m'
PURPLE='\033[1;35m'
NC='\033[0m'
[[ -v VISUAL && $VISUAL =~ '/vim'$ ]] && viewer=${VISUAL%/*}/view || viewer=${VISUAL:-$(command -v less)}

############################################################
### Process command-line arguments
############################################################

args=$(getopt -n "$0" -o 'c:p:s::u:n:frh' -l 'course:,project:,sid::,user:,names:,full,refresh,help' -- "$@") || emsg
eval set -- "$args"

while true; do
  case "$1" in
    -c|--course)
      course=$2
      shift 2
      ;;
    -p|--project)
      project=$2
      shift 2
      ;;
    -s|--sid)
      getprior=1
      [[ -n $2 ]] && sid=$2
      shift 2
      ;;
    -u|--user)
      user=$2
      setuser=1
      shift 2
      ;;
    -n|--names)
      namesfile=$2
      shift 2
      ;;
    -f|--full)
      paths=1
      shift
      ;;
    -r|--refresh)
      refresh=1
      shift
      ;;
    -h|--help)
      usage 0
      ;;
    --)
      shift
      break
      ;;
  esac
done

hasfiles=0
if [[ $# -ge 1 ]]; then
  hasfiles=1
fi
if (( hasfiles && getprior )); then
  emsg "-s option is incompatible with specifying files for a new submission"
fi

############################################################
### Create temp folder
############################################################

tempfold=$(mktemp --tmpdir -d clubXXXXXXXX)
function cleanup {
  rm -rf "$tempfold"
}
trap cleanup EXIT

############################################################
### Function to try updating club itself
############################################################
function maybe_update {
  local src current updated
  echo "Checking for updates to club itself..."
  src=$(readlink -f "$0")
  pushd "$(dirname "$src")"
  if ! current=$(git rev-parse HEAD); then
    echo "ERROR: club does not appear to exist in a git repo, so I don't know how to update it"
    exit 1
  fi
  if ! git pull; then
    echo "ERROR: could not pull new changes. Make sure you are on the USNA intranet"
    exit 1
  fi
  updated=$(git rev-parse HEAD)
  if [[ $current != $updated ]]; then
    echo "Update found! Please re-run club to use the new version."
    exit 0
  fi
  popd
  return 0
}

############################################################
### Function read names from namesfile and update $udisp
############################################################
function read_namesfile {
  # new globals: nametrans assoc array, $udisp display version of $user
  declare -gA nametrans=()
  declare -g udisp=$user
  local username dispname
  if [[ -n $namesfile ]]; then
    [[ -r $namesfile ]] || emsg "Could not read names file '$namesfile'"
    echo "Reading names translation from '$namesfile'"
    exec 4<"$namesfile"
    while read -u4 username dispname; do
      nametrans["$username"]=$dispname
      if [[ $dispname = $user ]]; then
        udisp=$dispname
        user=$username
      fi
    done
    exec 4<&-
  fi
  return 0
}

############################################################
### Function to make API request
############################################################
function api_request {
  # usage: api_request API_PATH OUTPUT_FILE [--nojq] [CURL_OPTIONS]
  # --nojq means don't process the output through json
  local tempout="$tempfold/api_out.json"
  local path=$1
  local ofile=$2
  local json=1
  shift 2
  [[ -n $apikey ]] || emsg "api_request needs apikey"
  if [[ $# -ge 1 && $1 = '--nojq' ]]; then
    shift
    json=0
  fi
  echo -n "Making API request for $path..."
  if ! $CURL -fsS -o "$tempout" "$@" "https://submit.usna.edu/api/$apikey/$path"; then
    echo <<EOF


ERROR accessing submit system API.
Make sure you are on the USNA intranet.
Try going to https://submit.usna.edu/ in a web browser to check that the
site is up and you are on the intranet.
You might need to download DoD certificates; try the instructions here:
  https://apt.cs.usna.edu/docs/ssl-system.html
You might have entered the wrong API key in the past. Try running:
  rm -f '$apifile'
to delete the saved key, then run this script again.
EOF
    exit 1
  fi
  echo -ne "\r                                                                        \r"
  if (( json )); then
    jq '.results' <"$tempout" >"$ofile"
  else
    cp "$tempout" "$ofile"
  fi
  rm "$tempout"
  return 0
}

############################################################
### Function to lookup and save API key
############################################################

function get_api_key {
  local submit_bin="$HOME/bin/submit" apisaved=0
  apikey=''
  if [[ -e $apifile ]]; then
    echo "Using API key from $apifile"
    apikey=$(cat "$apifile")
    apisaved=1
  elif [[ -e $submit_bin ]] && grep -q '^  apikey=' "$submit_bin" &>/dev/null; then
    echo "Trying to steal API key from $submit_bin"
    apikey=$(sed -n 's/^  apikey="\([^"]*\)"/\1/p' "$submit_bin")
  fi
  if [[ -z $apikey ]]; then
    cat <<EOF
Could not find your API key for submit. Let's look it up!
Open a browser and go to https://submit.usna.edu/
Log in (click the face on the top-left).
Then go to (Your username)->View/Reset API key
Your API key is shown in a box. Copy/paste it below.

EOF
    read -p "Your submit API key: " apikey
    api_request 'users/list' /dev/null
  fi
  if (( ! apisaved )); then
    echo "Saving API key to $apifile"
    echo "$apikey" >"$apifile"
  fi
  return 0
}

############################################################
### Function to display a menu
############################################################

function menu {
  # usage: menu [-d DEFAULT] [-p PROMPT] [-f FULL_DESCRIPTIONS] OPTIONS...
  # Each OPTION will be displayed along with a single letter to select it.
  # If -f FULL is given, FULL should be the name of an associative array of
  #   OPTION:DESCRIPTION pairs, and the corresponding DESCRIPTION is displayed
  #   for each OPTION.
  # DEFAULT is a default OPTION to select if they hit enter or space
  # Any OPTION starting with + is printed as-is as a string; it's not selectable.
  # The chosen option is saved in variable $menu_select
  unset menu_select
  local hasdesc=0
  local default=''
  local prompt='Choose an option from the list above: '
  local -A valid_opts=()
  local olet opt selected selectdef
  local -A opt_lookup=()
  while [[ $# -ge 1 && $1 =~ ^-. ]]; do
    if [[ $1 = '-d' ]]; then
      default="$2"
      shift 2
    elif [[ $1 = '-p' ]]; then
      prompt="$2"
      shift 2
    elif [[ $1 = '-f' ]]; then
      local -n desc="$2"
      hasdesc=1
      shift 2
    else
      break
    fi
  done
  echo
  for olet in {a..z} {A..Z} {0..9}; do
    while [[ $# -ge 1 && $1 =~ ^'+' ]]; do
      echo -e "${1:1}"
      shift
    done
    [[ $# -ge 1 ]] || break
    opt="$1"
    shift
    valid_opts["$olet"]=1
    echo -n "  $olet"
    if [[ $opt = $default ]]; then
      echo -n "  (default)"
    fi
    if (( hasdesc )) && [[ -v "desc[$opt]" ]]; then
      echo -e ": ${desc["$opt"]}"
    else
      echo ": $opt"
    fi
    opt_lookup["$olet"]=$opt
  done
  while (( 1 )); do
    IFS='' read -n1 -p "$prompt" selected
    selectdef=0
    [[ -z $selected ]] && selectdef=1 || echo
    [[ $selected = ' ' ]] && selectdef=1
    if (( selectdef )); then
      menu_select=$default
      return 0
    elif [[ -v "valid_opts[$selected]" ]]; then
      menu_select=${opt_lookup[$selected]}
      return 0
    fi
  done
}

############################################################
### Function to try reading from info file
############################################################
function try_info {
  local fcourse fproject
  if [[ -e $infofile ]]; then
    echo "Reading course and project from $infofile"
    read fcourse fproject <"$infofile"
    [[ -z $course ]] && course=$fcourse
    [[ -z $project ]] && project=$fproject
    [[ $course = $fcourse && $project = $fproject ]] && saveinfo=0
  fi
  return 0
}

############################################################
### Function to try saving to info file
############################################################
function save_info {
  if (( saveinfo )); then
    echo "Saving course=$course and project=$project to $infofile"
    echo "$course $project" >"$infofile"
  fi
  return 0
}

############################################################
### Function to select course number
############################################################
function get_course {
  local cnum
  local ulfile="$tempfold/ulfile.json"
  local -A cnums=()
  if [[ -z $course ]]; then
    echo "No course specified; looking up possible course numbers"
    api_request users/list "$ulfile"
    exec 4< <(jq -r '.[] .course' <"$ulfile")
    while read -u4 cnum; do
      cnums["$cnum"]=1
    done
    exec 4<&-
    menu -p "Which course? " "${!cnums[@]}"
    course=$menu_select
  fi
  return 0
}

############################################################
### Function to select project
############################################################
function get_project {
  # sets global vars $project, $pavail and $tavail
  local proj ptitle pclose this_tavail this_pavail anymatch
  local plfile="$tempfold/plfile.json"
  local -A projs=()
  local -a plist=()
  local -A pavail_lookup=()
  local -A tavail_lookup=()
  [[ -n $course ]] || emsg "get_project needs course"
  if [[ -n $project ]]; then
    echo "Looking up info for $course $project"
    api_request project/list "$plfile" -F "course=$course" -F "project=$project"
    exec 4< <(jq -r '.[] | [.project, .title, .close, (.testsavailable | tostring), (.pointsavailable | tostring)] | join(",")' <"$plfile")
    anymatch=0
    while IFS=, read -u4 proj ptitle pclose this_tavail this_pavail; do
      if [[ $proj != $project ]]; then
        emsg "project name mismatch in get_project"
      fi
      [[ -z $ptitle ]] && ptitle=$proj
      echo
      echo -e "  ${BLUE}Assignment: $ptitle$NC"
      echo -e "  ${BLUE}Deadline: $pclose$NC"
      echo
      tavail=$this_tavail
      pavail=$this_pavail
      anymatch=1
    done
    if (( ! anymatch )); then
      emsg "project '$project' not found for $course"
    fi
  else
    echo "No project specified; looking up possible projects for $course"
    api_request project/list "$plfile" -F "course=$course"
    exec 4< <(jq -r '.[] | [.project, .title, .close, (.testsavailable | tostring), (.pointsavailable | tostring)] | join(",")' <"$plfile")
    while IFS=, read -u4 proj ptitle pclose this_tavail this_pavail; do
      [[ -z $ptitle ]] && ptitle=$proj
      projs["$proj"]="($proj) $ptitle, due $pclose"
      plist+=( "$proj" )
      tavail_lookup["$proj"]=$this_tavail
      pavail_lookup["$proj"]=$this_pavail
    done
    exec 4<&-
    menu -p "Which assignment? " -f 'projs' "${plist[@]}"
    project=$menu_select
    tavail=${tavail_lookup["$project"]}
    pavail=${pavail_lookup["$project"]}
  fi
  if [[ $tavail = 'null' || $pavail = 'null' ]]; then
    tavail=0
    pavail=0
  fi
  return 0
}

############################################################
### Function to make a new submission
############################################################
function make_submission {
  # usage: make_submission FILES...
  local ufile="$tempfold/upload.tgz"
  local specuser=''
  (( $setuser )) && specuser="-F user=$user"
  [[ -n $course && -n $project ]] || emsg "make_submission needs course and project"
  local udir="$tempfold/updir"
  mkdir "$udir"
  local f frel
  local count=0
  local dest
  for f in "$@"; do
    if ! frel=$(realpath --canonicalize-existing --no-symlinks --relative-to=. "$f"); then
      echo "WARNING: file $f not found; skipping" >&2
      continue
    fi
    if (( paths )) && [[ $frel =~ [/] ]] && [[ ${frel%%/*} != '..' ]]; then
      dest="$udir/${frel%/*}"
      mkdir -p "$dest"
    else
      dest="$udir"
    fi
    if cp -L -r "$f" "$dest"/; then
      count=$(( count + 1 ))
    else
      echo "WARNING: could not read file '$f'" >&2
    fi
  done
  if (( count == 0 )); then
    echo "ERROR: no files to submit" >&2
    return 1
  fi
  pushd "$udir" >/dev/null
  find . '!' -type d -printf '%P\0' | xargs -0 -x -n 1024 tar --warning=none -czpf "$ufile"
  popd >/dev/null
  echo
  echo "Submitting $count files for $course $project"
  api_request submission/upload /dev/stdout --nojq -F "course=$course" -F "project=$project" $specuser -F "file=@$ufile"
  if (( ! setuser )); then
    # we just submitted, so no need to look at other users on the next step
    # N.B. could be a problem if local userid doesn't match submit. (So don't do that!)
    setuser=1
    user=$USER
  fi
  return 0
}

############################################################
### Function to get submission id
############################################################
function get_sid {
  local slfile="$tempfold/slfile.json"
  local specuser=''
  local xsid xuser xdate
  local -A choices=()
  local -A seluser=()
  local -a clist=()
  (( $setuser )) && specuser="-F user=$user"
  [[ -n $course && -n $project ]] || emsg "get_sid needs course and project"
  if [[ -n $sid ]]; then
    return 0
  elif (( $getprior )); then
    echo "Checking prior submissions for $course $project"
    api_request submission/list "$slfile" -F "course=$course" -F "project=$project" $specuser
    exec 4< <(jq -r '.[] | [(.sid|tostring), .user, .datestamp] | join(",")' <"$slfile")
    while IFS=, read -u4 xsid xuser xdate; do
      choices["$xsid"]="$xdate (${nametrans["$xuser"]:-$xuser})"
      seluser["$xsid"]=$xuser
      clist+=( "$xsid" )
    done
    exec 4<&-
  else
    echo "Checking most recent submissions for $course $project"
    api_request submission/recent "$slfile" -F "course=$course" -F "project=$project" $specuser
    exec 4< <(jq -r '.[] | [(.sid|tostring), .user, .datestamp] | join(",")' <"$slfile")
    while IFS=, read -u4 xsid xuser xdate; do
      choices["$xsid"]="${nametrans["$xuser"]:-$xuser} ($xdate)"
      seluser["$xsid"]=$xuser
      clist+=( "$xsid" )
    done
    exec 4<&-
  fi
  case ${#choices[@]} in
    0)
      emsg "No submissions found for $course $project"
      ;;
    1)
      sid=${clist[0]}
      ;;
    *)
      menu -p 'Which submission do you want? ' -f 'choices' "${clist[@]}"
      sid=$menu_select
      ;;
  esac
  user=${seluser["$sid"]}
  udisp=${nametrans["$user"]:-$user}
  return 0
}

############################################################
### Function to get list of test case files
############################################################
function get_files_list {
  # sets global arrays tfiles and sfiles as name->fid associative arrays
  local flistfile="$tempfold/flist.json"
  local fname fid haspri
  declare -gA sfiles=()
  declare -gA tfiles=()
  [[ -n $sid || -n $course || -n $project ]] || emsg "get_files_list needs sid, course, and project"
  echo "Getting submission files for SID $sid"
  api_request 'submission/list-files' "$flistfile" -F "sid=$sid"
  exec 4< <(jq -r '.[] | [.filename, (.sfid|tostring)] | join(",")' <"$flistfile")
  while IFS=, read -u4 fname fid; do
    sfiles["$fname"]=$fid
  done
  exec 4<&-
  echo "Getting test files for $course $project"
  api_request 'testfile/list' "$flistfile" -F "course=$course" -F "project=$project"
  exec 4< <(jq -r '.[] | [.filename, (.fid|tostring), (.has_priority|tostring)] | join(",")' <"$flistfile")
  while IFS=, read -u4 fname fid haspri; do
    if [[ -v "sfiles[$fname]" ]]; then
      if (( haspri )); then
        unset "sfiles[$fname]"
      else
        continue
      fi
    fi
    tfiles["$fname"]=$fid
  done
  exec 4<&-
  return 0
}

############################################################
### Helper function for pluralization
############################################################
function plural {
  # usage: n word [pluralization]
  # by default, puralization is adding s
  if (( $1 == 1 )); then
    echo "1 $2"
  elif [[ $# -ge 3 ]]; then
    echo "$1 $3"
  else
    echo "$1 $2s"
  fi
  return 0
}

############################################################
### Helper function to sleep and show rotating unicode
############################################################
function spin {
  # usage: spin NUM_SECONDS
  local secs=$1
  local -a characters=( \
    '\xF0\x9F\x90\x99' \
    '\xF0\x9F\x90\xA8' \
    '\xF0\x9F\x90\xAD' \
    '\xF0\x9F\x90\xAE' \
    '\xF0\x9F\x90\xB0' \
    '\xF0\x9F\x90\xB1' \
    '\xF0\x9F\x90\xB4' \
    '\xF0\x9F\x90\xB7' \
    '\xF0\x9F\x90\xB8' \
    '\xF0\x9F\x90\xBA' \
    '\xF0\x9F\x90\xBB' \
    '\xF0\x9F\x90\xBC' \
    )
  local nchars=${#characters[@]}
  local i=$(( RANDOM % nchars ))
  local j=$(( $1 * 3 ))
  while (( j > 0 )); do
    echo -en "${characters[i]}"
    j=$(( j - 1 ))
    i=$(( (i + 1) % nchars ))
    sleep 0.33s
    echo -en "\b\b"
  done
  echo -en "${characters[i]}"
  return 0
}

############################################################
### Function to download test results
############################################################
function dl_testres {
  # saves results to file $testres_file and sets $points_earned
  # also updates $user and $udisp
  local -A testsgot=()
  local name points pass xuname uname=''
  declare -g testres_file="$tempfold/testres.json"
  [[ -n $sid || -n $tavail || -n $pavail ]] || emsg "dl_testres needs sid and tavail"
  declare -g points_earned=0
  if [[ $tavail -eq 0 ]]; then
    echo "No test cases for this assignment."
    testres_file='/dev/null'
    return 0
  fi
  echo
  echo "Fetching autotest results for $course $project SID $sid"
  while (( 1 )); do
    api_request 'results/list' "$testres_file" -F "sid=$sid"
    exec 4< <(jq -r '.[] | [.user, .rulename, (.points|tostring), (.pass|tostring)] | join(",")' <"$testres_file")
    while IFS=, read -u4 xuname name points pass; do
      [[ -z $uname ]] && uname=$xuname
      [[ -v "testsgot[$name]" ]] && continue
      testsgot["$name"]=1
      if (( pass )); then
        echo -e "  ${GREEN}$name: pass ($(plural $points point))$NC"
        points_earned=$(( points_earned + points ))
      else
        echo -e "  ${RED}$name: FAIL ($(plural $points point))$NC"
      fi
    done
    exec 4<&-
    [[ ${#testsgot[@]} -ge $tavail ]] && break
    echo -n "(waiting for all the tests to run...)"
    spin "$poll_interval"
    echo -ne "\r                                 \r"
  done
  if [[ -n $uname ]]; then
    user=$uname
    udisp=${nametrans["$user"]:-$user}
  fi
  echo -e "${BLUE}Total points earned: $points_earned / $pavail$NC"
  return 0
}

############################################################
### Function to show a single test/student file
############################################################
function show_file {
  # usage: show_file (t|s) filename
  local tfdir="$tempfold/files"
  local ts=$1 fname=$2
  local apipath opath opdir
  opath="$tfdir/$fname"
  opdir=$(dirname "$opath")
  mkdir -p "$opdir"
  if [[ ! -e $opath ]]; then
    case "$ts" in
      t)
        apipath="testfile/pull-file/${tfiles["$fname"]}"
        ;;
      s)
        apipath="submission/pull-file/${sfiles["$fname"]}"
        ;;
      *)
        emsg "unexpected 1st argument to show_file: '$ts'"
        ;;
    esac
    api_request "$apipath" "$opath" --nojq
  fi
  $viewer "$opath"
  return 0
}

############################################################
### Helper function to print a header line
############################################################
function header {
  # usage: header COLS TEXT
  local cols=$1 message lwid rwid
  shift
  message=$*
  if (( ${#message} > cols - 4 )); then
    echo -e "${BLUE}==${message:0:$(( cols - 4 ))}==$NC"
  else
    lwid=$(( ( cols - ${#message} ) / 2 ))
    rwid=$(( cols - ${#message} - lwid ))
    echo -e "${BLUE}$(head -c "$lwid" </dev/zero | tr '\0' '=')$message$(head -c "$rwid" </dev/zero | tr '\0' '=')$NC"
  fi
  return 0
}

############################################################
### Helper function to print first n lines of a file
############################################################
function firstn {
  # usage: LINES COLS FNAME
  local lines=$1 cols=$2 fname=$3 flines
  flines=$(wc -l <"$fname")
  if (( flines <= lines )); then
    cat "$fname" | cut -c "-$cols"
  else
    head -n $(( lines - 1 )) "$fname" | cut -c "-$cols"
    echo -e "${PURPLE}...and $(( flines - ( lines - 1 ) )) more lines$NC"
  fi
  return 0
}

############################################################
### Function to summarize a single test case
############################################################
function show_tcase {
  # usage: show_tcase RULENAME
  local name=$1
  local ctarget rtarget points pass stime returnval max_lines cols match key
  local tcase_file="$tempfold/tcase.json"
  local input="$tempfold/tcase-input.txt"
  local actual_out="$tempfold/tcase-actout.txt"
  local expected_out="$tempfold/tcase-expout.txt"
  local errout="$tempfold/tcase-errout.txt"
  local dfile="$tempfold/tcase-diff.txt"
  local -a tmlist=()
  local -A tmdesc=()
  [[ -e $testres_file ]] || emsg "show_tcase needs testres_file"
  jq ".[] | select(.rulename == \"$name\")" <"$testres_file" >"$tcase_file"
  ctarget=$(jq -r '.compile_target' <"$tcase_file")
  rtarget=$(jq -r '.run_target' <"$tcase_file")
  points=$(jq -r '.points' <"$tcase_file")
  pass=$(jq -r '.pass' <"$tcase_file")
  stime=$(jq -r '.stime' <"$tcase_file")
  returnval=$(jq -r '.returnval' <"$tcase_file")
  jq -j '.stdin' <"$tcase_file" >"$input"
  jq -j '.outvalue' <"$tcase_file" >"$expected_out"
  jq -j '.diff' <"$tcase_file" >"$actual_out"
  jq -j '.stderr' <"$tcase_file" >"$errout"
  match=0
  diff -u1000 "$actual_out" "$expected_out" | tail -n +4 >"$dfile" && match=1
  max_lines=$(( ${LINES:-50} / 3 ))
  cols=${COLUMNS:-72}

  key="f:$input"
  tmlist+=( "$key" )
  tmdesc["$key"]="Open input with $viewer"

  key="f:$expected_out"
  tmlist+=( "$key" )
  tmdesc["$key"]="Open expected output with $viewer"

  key="f:$actual_out"
  tmlist+=( "$key" )
  tmdesc["$key"]="Open actual output with $viewer"

  key="f:$errout"
  tmlist+=( "$key" )
  tmdesc["$key"]="Open std error with $viewer"

  key='back'
  tmlist+=( "$key" )
  tmdesc["$key"]="Go back to the main menu"

  key='quit'
  tmlist+=( "$key" )
  tmdesc["$key"]="Quit"

  while (( 1 )); do
    clear -x
    echo -e "${BLUE}$course $project test case '$name' user '$udisp'$NC"
    echo "Ran 'make $rtarget' in $stime seconds with return code $returnval"
    if [[ -s $input ]]; then
      header "$cols" "Input"
      firstn $max_lines $cols "$input"
    fi
    if (( match )); then
      header $cols "Output"
      firstn $max_lines $cols "$actual_out"
    else
      header $cols "Output differences"
      echo " COMMON LINE"
      echo -e "${RED}-LINE IN YOUR OUTPUT ONLY$NC"
      echo -e "${GREEN}+LINE IN EXPECTED OUTPUT ONLY$NC"
      firstn $max_lines $cols "$dfile" | \
        sed -e 's/^+\(.*\)$/'$(echo -e "$GREEN")'+\1'$(echo -e "$NC")'/' \
        -e 's/^-\(.*\)$/'$(echo -e "$RED")'-\1'$(echo -e "$NC")'/'
    fi
    if [[ -s $errout ]]; then
      header $cols "Standard error"
      firstn $max_lines $cols "$errout" | \
        sed 's/^\(.*\)$/'$(echo -e "$RED")'\1'$(echo -e "$NC")'/'
    fi
    header $cols "RESULTS"
    if (( pass )); then
      echo -e "${GREEN}PASSED ($points / $(plural $points point))$NC"
    else
      echo -e "${RED}FAILED (0 / $points points)$NC"
    fi

    menu -d 'back' -p 'What do you want to do? ' -f 'tmdesc' "${tmlist[@]}"
    case "$menu_select" in
      f:*)
        $viewer "${menu_select#*:}"
        ;;
      back)
        return 0
        ;;
      quit)
        return 1
        ;;
      *)
        emsg "unexpected menu_select in show_tcase: '$menu_select'"
        ;;
    esac
  done
}

############################################################
### Function to show the main menu
############################################################
function main_menu {
  local -A menuopts=()
  local -a menulist=()
  local tnfile="$tempfold/tnames.txt"
  local name points pass key desc stem earned=0
  if [[ ${#tfiles[@]} -ge 1 ]]; then
    menulist+=( "+${BLUE}Instructor-provided files$NC (open with $viewer):" )
    for fname in "${!tfiles[@]}"; do
      key="tfile:$fname"
      menuopts["$key"]=$fname
      menulist+=( "$key" )
    done
  fi
  if [[ ${#sfiles[@]} -ge 1 ]]; then
    [[ ${#menulist[@]} -gt 0 ]] && menulist+=( "+" )
    menulist+=( "+${BLUE}Student-submitted files$NC (open with $viewer):" )
    for fname in "${!sfiles[@]}"; do
      key="sfile:$fname"
      menuopts["$key"]=$fname
      menulist+=( "$key" )
    done
  fi
  [[ ${#menulist[@]} -gt 0 ]] && menulist+=( "+" )
  menulist+=( "+${BLUE}Test cases$NC:" )
  exec 4< <(jq -r '.[] | [.rulename, (.points|tostring), (.pass|tostring)] | join(",")' <"$testres_file")
  exec 5>"$tnfile"
  while IFS=, read -u4 name points pass; do
    if (( pass )); then
      desc="${GREEN}$name: PASS ($(plural $points point))$NC"
      earned=$(( earned + points ))
    else
      desc="${RED}$name: FAIL ($(plural $points point))$NC"
    fi
    echo "$name" >&5
    menuopts["tcase:$name"]=$desc
  done
  exec 4<&-
  exec 5>&-
  exec 4< <(sort "$tnfile")
  while read -u4 name; do
    menulist+=( "tcase:$name" )
  done
  exec 4<&-
  menulist+=( "+${BLUE}Total points earned: $earned / $pavail$NC" )
  menulist+=( '+' 'quit' )
  menuopts['quit']='Quit'
  while (( 1 )); do
    clear -x
    echo -e "${BLUE}$course $project user '$udisp' test results$NC"
    menu -p 'Select an option: ' -d 'quit' -f 'menuopts' "${menulist[@]}"
    case "${menu_select%%:*}" in
      ?file)
        show_file "${menu_select:0:1}" "${menu_select#*:}"
        ;;
      tcase)
        show_tcase "${menu_select#*:}" || break
        ;;
      quit)
        break
        ;;
      *)
        emsg "Unexpected menu selection '$menu_select'"
        ;;
    esac
  done
  return 0
}

############################################################
### This is "main" - do the actual stuff
############################################################
if (( refresh )); then
  maybe_update
fi
read_namesfile
get_api_key
try_info
get_course
get_project
if (( $hasfiles )); then
  make_submission "$@"
fi
get_sid
get_files_list
dl_testres
save_info
main_menu
echo "Goodbye!"

:
